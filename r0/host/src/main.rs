// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
extern crate num_bigint as bigint;

use bigint::BigUint;
use methods::{MOD_EXP_IN_RANGE_ELF, MOD_EXP_IN_RANGE_ID};
use risc0_zkvm::serde::to_vec;
use risc0_zkvm::{default_prover, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let base: BigUint = BigUint::parse_bytes(b"4", 10).unwrap();
    let modulus: BigUint = BigUint::parse_bytes(
        b"00a09ecd8ada2a30634181e1bf5452b92268d2373ad4b234c750b79cb09cb2c82f2fd51310d7a771f44ccf58b46d94c156107c0695d289adb58280d8479da80b4f", 
        16,
    )
    .unwrap();
    let range: BigUint = modulus.clone() / BigUint::parse_bytes(b"5000000", 10).unwrap();
    println!("range: {:?}", range.to_str_radix(16));
    let exp: BigUint = BigUint::parse_bytes(b"b7c8d9", 16).unwrap();

    let env = ExecutorEnv::builder()
        .write(&to_vec(&base.clone()).unwrap())
        .unwrap() // base
        .write(&to_vec(&modulus.clone()).unwrap())
        .unwrap() // modulus
        .write(&to_vec(&range.clone()).unwrap())
        .unwrap() // range
        .write(&to_vec(&exp.clone()).unwrap())
        .unwrap() // exp
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let receipt = prover.prove(env, MOD_EXP_IN_RANGE_ELF).unwrap().receipt;

    let (base_res, modulus_res, range_res, result): (BigUint, BigUint, BigUint, BigUint) =
        receipt.journal.decode().unwrap();

    println!("Proof complete!");
    println!("base: {:?}", base_res);
    println!("modulus: {:?}", modulus_res);
    println!("range: {:?}", range_res);
    println!("result: {:?}", result);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(MOD_EXP_IN_RANGE_ID).unwrap();
}
